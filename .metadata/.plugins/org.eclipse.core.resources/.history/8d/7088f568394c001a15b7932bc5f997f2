#include <stdio.h>
#include <stddef.h>
#include <stdlib.h>
#include <errno.h>
#include <dirent.h>
#include <limits.h>
#include <string.h>
#include <sys/iofunc.h>
#include <sys/dispatch.h>
 
#define ALIGN(x)  (((x) + 3) & ~3)
#define NUM_ENTS   26
 
static iofunc_attr_t  atoz_attrs [NUM_ENTS];
 
static int my_open (resmgr_context_t *ctp, io_open_t *msg,
                    iofunc_attr_t *attr, void *extra);
static int my_read (resmgr_context_t *ctp, io_read_t *msg,
                    iofunc_ocb_t *ocb);
static int my_write (resmgr_context_t *ctp, io_write_t *msg,
                    iofunc_ocb_t *ocb);
static int my_read_dir (resmgr_context_t *ctp, io_read_t *msg,
                        iofunc_ocb_t *ocb);
static int my_read_file (resmgr_context_t *ctp, io_read_t *msg,
                         iofunc_ocb_t *ocb);
int dirent_size (char *fname);
struct dirent * dirent_fill (struct dirent *dp, int inode, int offset, char *fname);
static void process_data(char *req);
 
int main (int argc, char **argv)
{
    dispatch_t               *dpp;
    resmgr_attr_t            resmgr_attr;
    resmgr_context_t         *ctp;
    resmgr_connect_funcs_t   connect_func;
    resmgr_io_funcs_t        io_func;
    iofunc_attr_t            attr;
    int                      i;
 
    // Создать структуру диспетчеризации
    if ((dpp = dispatch_create ()) == NULL)
    {
        perror ("Ошибка dispatch_create\n");
        exit (EXIT_FAILURE);
    }
 
    // Инициализировать структуры данных
    memset (&resmgr_attr, 0, sizeof (resmgr_attr));
    resmgr_attr.nparts_max = 1;
    resmgr_attr.msg_max_size = 2048;
 
    // Назначить обработчики по умолчанию
    iofunc_func_init (_RESMGR_CONNECT_NFUNCS, &connect_func,
                      _RESMGR_IO_NFUNCS, &io_func);
 
    // Создать и инициализировать атрибутную запись для каталога ...
    iofunc_attr_init (&attr, S_IFDIR | 0555, 0, 0);
    attr.inode = NUM_ENTS + 1; // 1-26 зарезервированы для файлов от "a" до "z"
    attr.nbytes = NUM_ENTS;
 
    // И для имен от "a" до "z"
    for (i = 0; i < NUM_ENTS; i++)
    {
        iofunc_attr_init (&atoz_attrs [i], S_IFREG | 0444, 0, 0);
        atoz_attrs[i].inode = i + 1;
        atoz_attrs[i].nbytes = 1;
    }
 
    // Добавить наши функции; Нам интересны только io_open и io_read
    connect_func.open = my_open;
    io_func.read = my_read;
    io_func.write = my_write;
 
    // Зарегестрировать префикс
    if (resmgr_attach (dpp, &resmgr_attr, "/dev/atoz",
                       _FTYPE_ANY, _RESMGR_FLAG_DIR, &connect_func, &io_func, &attr) == -1)
    {
        perror ("Ошибка resmgr_attach\n");
        exit (EXIT_FAILURE);
    }
 
    // Выделить контекст
    ctp = resmgr_context_alloc (dpp);
 
    // Ждать сообщений в вечном цикле
    while (1)
    {
        if ((ctp = resmgr_block (ctp)) == NULL)
        {
            perror ("Ошибка resmgr_block\n");
            exit (EXIT_FAILURE);
        }
        resmgr_handler (ctp);
    }
}
 
 
static int my_open (resmgr_context_t *ctp, io_open_t *msg,
                    iofunc_attr_t *attr, void *extra)
{
	printf("OPEN\n");
    if (msg -> connect.path [0] == 0)   // Это каталог /dev/atoz
    {
        return (iofunc_open_default (ctp, msg, attr, extra));
    } else if ( (msg -> connect.path[1]) == 0   &&
                ((msg->connect.path[0] >= 'a') &&
                 msg -> connect.path[0] <= 'z')   )
    {
        return (iofunc_open_default (ctp, msg, atoz_attrs + msg->connect.path[0] - 'a', extra));
    } else
    {
        return (ENOENT);
    }
}
 
static int my_read (resmgr_context_t *ctp, io_read_t *msg,
                    iofunc_ocb_t *ocb)
{
	printf("read\n");
    int sts;
 
    // Использовать вспомогательную функцию для проверки корректности
    if ((sts = iofunc_read_verify (ctp, msg, ocb, NULL)) != EOK)
        return (sts);
    // Решить, надо ли читать файл или каталог
    if (S_ISDIR (ocb ->attr -> mode))
    {
        return (my_read_dir (ctp, msg, ocb));
    } else if (S_ISREG (ocb -> attr -> mode))
    {
        return (my_read_file (ctp, msg, ocb));
    } else
    {
        return (EBADF);
    }
}
 
 
static int my_write(resmgr_context_t *ctp, io_write_t *msg, iofunc_ocb_t *ocb) {
    int max_value = 512 * 1024;
    char value[max_value + 1];
    int len_v = max_value;
   
 
    printf("WRITE\n");
 
    _IO_SET_WRITE_NBYTES(ctp, msg->i.nbytes);
    resmgr_msgread(ctp, value, len_v, sizeof(msg->i));
    value[--len_v] = 0;
 
 
    process_data(value);
 
    return (_RESMGR_NPARTS(0));
}
 
void process_data(char *req) {
    char *command = strtok(req," ");
    if (strcmp(command,"MOUNT")){
        //mount(NULL,dir,_MOUNT_READONLY,'qnx6',?,?)
    }
    if (strcmp(command,"UNMOUNT")){
        //umount(dir,NULL)
    }
}
 
static int my_read_dir (resmgr_context_t *ctp, io_read_t *msg,
                        iofunc_ocb_t *ocb)
{
    int nbytes;
    int nleft;
    struct dirent *dp;
    char *reply_msg;
    char fname [_POSIX_PATH_MAX];
 
    // Выделить буфер для ответа
    reply_msg = (char *) calloc (1, msg -> i.nbytes);
    if (reply_msg == NULL)
        return (ENOMEM);
 
    // Назначить выходной буфер
    dp = (struct dirent *) reply_msg;
 
    // Осталось nleft байт
    nleft = msg -> i.nbytes;
    while (ocb -> offset < NUM_ENTS)
    {
        // Создать имя файла
        sprintf (fname, "%c", ocb -> offset + 'a');
 
        // Проверить, насколько велик результат
        nbytes = dirent_size (fname);
 
        // Есть место?
        if (nleft - nbytes >= 0)
        {
            // Заполнить элемент каталога и увеличить указатель
            dp = dirent_fill (dp, ocb -> offset + 1, ocb -> offset, fname);
            // Увеличить смещение OCB
            ocb -> offset++;
            // Учесть, сколько байт мы использовали
            nleft -= nbytes;
        } else
        {
            // Места больше нет, остановиться
            break;
        }
    }
 
    // Возвращаемся обратно к клиенту
    MsgReply (ctp -> rcvid, (char *) dp - reply_msg,
              reply_msg, (char *) dp - reply_msg);
    // Освободить буфер
    free (reply_msg);
 
    // Сказать библиотеке, что мы уже ответили сами
    return (_RESMGR_NOREPLY);
}
 
static int my_read_file (resmgr_context_t *ctp, io_read_t *msg,
                         iofunc_ocb_t *ocb)
{
    int nbytes;
    int nleft;
    char string;
 
    // Тут нет никаких xtype...
    if ((msg -> i.xtype & _IO_XTYPE_MASK) != _IO_XTYPE_NONE)
        return (ENOSYS);
 
    // Выяснить, сколько байт осталось...
    nleft = ocb->attr->nbytes - ocb->offset;
    // ... и сколько мы можем возвратить клиенту
    nbytes = __min (nleft, msg->i.nbytes);
 
    if (nbytes)
    {
        // Создать ответную строку
        string = ocb->attr->inode -1 + 'A';
        // Возвратить ее клиенту
        MsgReply (ctp->rcvid, nbytes, &string + ocb->offset, nbytes);
        // Обновить флаги и смещение
        ocb->attr->flags |= IOFUNC_ATTR_ATIME | IOFUNC_ATTR_DIRTY_TIME;
        ocb->offset += nbytes;
    } else
    {
        // Возвращать нечего, индуцировать конец файла
        MsgReply (ctp->rcvid, EOK, NULL, 0);
    }
    // Уже ответили сами
    return (_RESMGR_NOREPLY);
}
 
int dirent_size (char *fname)
{
    return (ALIGN(sizeof(struct dirent) - 4 + strlen(fname)));
}
 
struct dirent * dirent_fill (struct dirent *dp, int inode, int offset, char *fname)
{
    dp -> d_ino = inode;
    dp -> d_offset = offset;
    strcpy (dp -> d_name, fname);
    dp->d_namelen = strlen (dp->d_name);
    dp->d_reclen = ALIGN (sizeof(struct dirent) - 4 + dp->d_namelen);
    return ((struct dirent *) ((char *) dp + dp->d_reclen));
}